package main

import (
	"database/sql"
	"fmt"
	"os"
	"testing"

	"github.com/Jun-Chang/gdbinder/example"
	_ "github.com/go-sql-driver/mysql"
	"gopkg.in/gorp.v1"
)

var db *sql.DB
var dbMap *gorp.DbMap

func init() {
	var err error

	// initialize sql.DB
	host := os.Getenv("GDBINDER_TEST_MYSQL_HOST")
	database := os.Getenv("GDBINDER_TEST_MYSQL_DATABASE")
	usr := os.Getenv("GDBINDER_TEST_MYSQL_USER")
	pass := os.Getenv("GDBINDER_TEST_MYSQL_PASSWORD")

	if db, err = sql.Open("mysql", fmt.Sprintf("%s:%s@tcp(%s)/%s", usr, pass, host, database)); err != nil {
		panic(err)
	}

	// initialize gorp & tables
	dbMap = &gorp.DbMap{
		Db:      db,
		Dialect: gorp.MySQLDialect{"InnoDB", "UTF8"},
	}
	dbMap.AddTableWithName(example.TestStruct{}, "gdbinder_test").SetKeys(true, "ID")
	dbMap.AddTableWithName(example.TestStruct2{}, "gdbinder_test2").SetKeys(true, "ID")
	if err = dbMap.CreateTablesIfNotExists(); err != nil {
		panic(err)
	}

	// clear tables.
	// caution! you have to specify test database.
	if err = dbMap.TruncateTables(); err != nil {
		panic(err)
	}

	// insert test fixtures;
	if err := dbMap.Insert(&example.TestStruct{
		ID: 1,
	}); err != nil {
		panic(err)
	}
	if err := dbMap.Insert(&example.TestStruct2{
		ID: 1,
	}); err != nil {
		panic(err)
	}
}

func TestSearchTag(t *testing.T) {
	nm := "searchTag"

	exp := `db:"ok"`
	if res := searchTag(exp); res != "ok" {
		t.Fatalf("%s is faild expected: %s actual %s", nm, "ok", res)
	}

	exp = `db:"ok" foo:"bar"`
	if res := searchTag(exp); res != "ok" {
		t.Fatalf("%s is faild expected: %s actual %s", nm, "ok", res)
	}

	exp = `invalid`
	if res := searchTag(exp); res != "" {
		t.Fatalf("%s is faild expected: %s actual %s", nm, "ok", res)
	}

	exp = ``
	if res := searchTag(exp); res != "" {
		t.Fatalf("%s is faild expected: %s actual %s", nm, "ok", res)
	}
}

func TestSearchStruct(t *testing.T) {
	nm := "searchStruct"

	args := "TestStruct"
	typeNm = &args

	pkgName, structName, structType, err := searchStruct("./example")

	if err != nil {
		t.Fatalf("%s is faild error: %v", nm, err)
	}

	if pkgName != "example" {
		t.Fatalf("%s is faild expected: %s actual %s", nm, "example", pkgName)
	}

	if structName != args {
		t.Fatalf("%s is faild expected: %s actual %s", nm, args, structName)
	}

	if structType == nil {
		t.Fatalf("%s is faild %s is nil", nm, args)
	}
}

func TestGen(t *testing.T) {
	nm := "gen"

	args := "TestStruct"
	typeNm = &args

	pkgName, structName, structType, _ := searchStruct("./example")

	b, err := gen(pkgName, structName, structType)

	if err != nil {
		t.Fatalf("%s is faild error: %v", nm, err)
	}

	expected := `// DO NOT EDIT!
// Code generated by gdbinder <https://github.com/Jun-Chang/gdbinder>

package example

import "database/sql"

func TestStructClmns() string {
	return "id,col1,col2,col3,col4,col5,col6,col7,col8,col9"
}

func TestStructScan(rs *sql.Rows) ([]*TestStruct, error) {
	bound := []*TestStruct{}
	for rs.Next() {
		b := TestStruct{}
		if err := rs.Scan(&b.ID, &b.Col1, &b.Col2, &b.Col3, &b.Col4, &b.Col5, &b.Col6, &b.Col7, &b.Col8, &b.Col9); err != nil {
			return nil, err
		}
		bound = append(bound, &b)
	}

	return bound, nil
}
`
	actual := string(b)

	if actual != expected {
		t.Fatalf("%s is faild expected\n%s actual\n%s", nm, expected, actual)
	}
}

func BenchmarkGdbinderColumn10(b *testing.B) {
	for i := 0; i < b.N; i++ {
		 if _, err := example.FindStruct(db); err != nil {
			 b.Fatal(err)
		}
	}
}
func BenchmarkGorpColumn10(b *testing.B) {
	for i := 0; i < b.N; i++ {
		query := "SELECT * FROM gdbinder_test"
		ts := []*example.TestStruct{}
		if _, err := dbMap.Select(&ts, query); err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkGdbinderColumn100(b *testing.B) {
	for i := 0; i < b.N; i++ {
		if _, err := example.FindStruct2(db); err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkGorpColumn100(b *testing.B) {
	for i := 0; i < b.N; i++ {
		query := "SELECT * FROM gdbinder_test2"
		ts := []*example.TestStruct2{}
		if _, err := dbMap.Select(&ts, query); err != nil {
			b.Fatal(err)
		}
	}
}
